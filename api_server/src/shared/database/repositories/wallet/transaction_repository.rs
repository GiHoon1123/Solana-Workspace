use sqlx::{PgPool, Row};
use anyhow::{Context, Result};
use chrono::Utc;
use crate::domains::wallet::models::{Transaction, TransactionStatus};

// 트랜잭션 레포지토리
// 역할: NestJS의 Repository 같은 것
// TransactionRepository: handles all database operations for transactions
pub struct TransactionRepository {
    pool: PgPool,
}

impl TransactionRepository {
    // 레포지토리 생성
    // Create repository instance
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }

    // 트랜잭션 저장
    // Save transaction to database
    // DB에서 id를 자동 생성하므로 id는 바인딩하지 않음
    // ID is auto-generated by DB, so we don't bind it
    // Note: PostgreSQL BIGSERIAL은 signed BIGINT이지만, 실제 값은 양수만 사용하므로
    //       Rust에서는 u64로 타입 변환 필요 (sqlx가 자동 처리)
    pub async fn save_transaction(
        &self,
        input_mint: &str,
        output_mint: &str,
        amount: u64,
        expected_out_amount: Option<u64>,
        user_public_key: &str,
        transaction_bytes: &str,
        quote_response: Option<serde_json::Value>,
        status: TransactionStatus,
    ) -> Result<Transaction> {
        let status_str = status.as_str();

        // 트랜잭션 삽입 및 반환 (id는 DB에서 자동 생성)
        // Insert transaction and return (id is auto-generated by DB)
        // PostgreSQL BIGSERIAL은 signed BIGINT이지만, 실제 값은 양수만 사용
        // sqlx는 이를 i64로 매핑하므로, 수동으로 u64로 변환 필요
        let row = sqlx::query(
            r#"
            INSERT INTO transactions (
                input_mint, output_mint, amount, expected_out_amount,
                user_public_key, transaction_bytes, quote_response, status, created_at
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
            RETURNING id, input_mint, output_mint, amount, expected_out_amount,
                      user_public_key, transaction_bytes, quote_response, status, created_at
            "#,
        )
        .bind(input_mint)
        .bind(output_mint)
        .bind(amount as i64)  // PostgreSQL BIGINT는 signed이므로 i64로 변환
        .bind(expected_out_amount.map(|v| v as i64))  // Option<u64> -> Option<i64>
        .bind(user_public_key)
        .bind(transaction_bytes)
        .bind(quote_response.as_ref())
        .bind(status_str)
        .bind(Utc::now())
        .fetch_one(&self.pool)
        .await
        .context("Failed to save transaction to database")?;

        // i64를 u64로 변환하여 Transaction 생성
        Ok(Transaction {
            id: row.get::<i64, _>("id") as u64,
            input_mint: row.get("input_mint"),
            output_mint: row.get("output_mint"),
            amount: row.get::<i64, _>("amount") as u64,
            expected_out_amount: row.get::<Option<i64>, _>("expected_out_amount").map(|v| v as u64),
            user_public_key: row.get("user_public_key"),
            transaction_bytes: row.get("transaction_bytes"),
            quote_response: row.get("quote_response"),
            status: row.get("status"),
            created_at: row.get("created_at"),
        })
    }

    // 트랜잭션 조회 (ID로)
    // Get transaction by ID
    pub async fn get_transaction(&self, id: u64) -> Result<Option<Transaction>> {
        let row = sqlx::query(
            r#"
            SELECT id, input_mint, output_mint, amount, expected_out_amount,
                   user_public_key, transaction_bytes, quote_response, status, created_at
            FROM transactions
            WHERE id = $1
            "#,
        )
        .bind(id as i64)  // u64 -> i64 변환
        .fetch_optional(&self.pool)
        .await
        .context("Failed to fetch transaction from database")?;

        let row = match row {
            Some(r) => r,
            None => return Ok(None),
        };

        // i64를 u64로 변환하여 Transaction 생성
        Ok(Some(Transaction {
            id: row.get::<i64, _>("id") as u64,
            input_mint: row.get("input_mint"),
            output_mint: row.get("output_mint"),
            amount: row.get::<i64, _>("amount") as u64,
            expected_out_amount: row.get::<Option<i64>, _>("expected_out_amount").map(|v| v as u64),
            user_public_key: row.get("user_public_key"),
            transaction_bytes: row.get("transaction_bytes"),
            quote_response: row.get("quote_response"),
            status: row.get("status"),
            created_at: row.get("created_at"),
        }))
    }

    // 트랜잭션 목록 조회 (사용자별)
    // Get transactions by user public key
    pub async fn get_transactions_by_user(
        &self,
        user_public_key: &str,
        limit: Option<u64>,
    ) -> Result<Vec<Transaction>> {
        let limit = limit.unwrap_or(100) as i64;  // u64 -> i64 변환

        let rows = sqlx::query(
            r#"
            SELECT id, input_mint, output_mint, amount, expected_out_amount,
                   user_public_key, transaction_bytes, quote_response, status, created_at
            FROM transactions
            WHERE user_public_key = $1
            ORDER BY created_at DESC
            LIMIT $2
            "#,
        )
        .bind(user_public_key)
        .bind(limit)
        .fetch_all(&self.pool)
        .await
        .context("Failed to fetch transactions from database")?;

        // i64를 u64로 변환하여 Transaction 벡터 생성
        let transactions = rows
            .into_iter()
            .map(|row| Transaction {
                id: row.get::<i64, _>("id") as u64,
                input_mint: row.get("input_mint"),
                output_mint: row.get("output_mint"),
                amount: row.get::<i64, _>("amount") as u64,
                expected_out_amount: row.get::<Option<i64>, _>("expected_out_amount").map(|v| v as u64),
                user_public_key: row.get("user_public_key"),
                transaction_bytes: row.get("transaction_bytes"),
                quote_response: row.get("quote_response"),
                status: row.get("status"),
                created_at: row.get("created_at"),
            })
            .collect();

        Ok(transactions)
    }
}